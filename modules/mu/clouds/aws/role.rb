# Copyright:: Copyright (c) 2018 eGlobalTech, Inc., all rights reserved
#
# Licensed under the BSD-3 license (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the root of the project or at
#
#     http://egt-labs.com/mu/LICENSE.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module MU
  class Cloud
    class AWS
      # A user as configured in {MU::Config::BasketofKittens::roles}
      class Role < MU::Cloud::Role
        @deploy = nil
        @config = nil
        attr_reader :mu_name
        attr_reader :config
        attr_reader :cloud_id

        # @param mommacat [MU::MommaCat]: A {MU::Mommacat} object containing the deploy of which this resource is/will be a member.
        # @param kitten_cfg [Hash]: The fully parsed and resolved {MU::Config} resource descriptor as defined in {MU::Config::BasketofKittens::roles}
        def initialize(mommacat: nil, kitten_cfg: nil, mu_name: nil, cloud_id: nil)
          @deploy = mommacat
          @config = MU::Config.manxify(kitten_cfg)
          @cloud_id ||= cloud_id
          @mu_name = mu_name
          @mu_name ||= @deploy.getResourceName(@config["name"])
        end

        # Called automatically by {MU::Deploy#createResources}
        def create
          if @config['iam_policies']
            @config['iam_policies'].each { |policy|
              policy_name = @mu_name+"-"+policy.keys.first.upcase
              MU.log "Creating IAM policy #{policy_name}"
              resp = MU::Cloud::AWS.iam.create_policy(
                policy_name: policy_name,
                path: "/"+@deploy.deploy_id+"/",
                policy_document: JSON.generate(policy.values.first),
                description: "Generated from inline policy document for Mu role #{@mu_name}"
              )
            }
          end

          if !@config['bare_policies']
            MU.log "Creating IAM role #{@mu_name}"
            resp = MU::Cloud::AWS.iam.create_role(
              path: "/"+@deploy.deploy_id+"/",
              role_name: @mu_name,
              description: "Generated by Mu",
              assume_role_policy_document: gen_role_policy_doc,
              tags: get_tag_params
            )
          end
        end

        # Called automatically by {MU::Deploy#createResources}
        def groom
          if !@config['bare_policies']
            resp = MU::Cloud::AWS.iam.get_role(
              role_name: @mu_name
            ).role
            ext_tags = resp.tags.map { |t| t.to_h }
            tag_param = get_tag_params(true)
            tag_param.reject! { |t| ext_tags.include?(t) }

            if tag_param.size > 0
              MU.log "Updating tags on IAM role #{@mu_name}", MU::NOTICE, details: tag_param
              MU::Cloud::AWS.iam.tag_role(role_name: @mu_name, tags: tag_param)
            end
          end

          if @config['iam_policies']
            attached_policies = []
            configured_policies = @config['iam_policies'].map { |p|
              @mu_name+"-"+p.keys.first.upcase
            }

            if !@config['bare_policies']
              attached_policies = MU::Cloud::AWS.iam.list_attached_role_policies(
                role_name: @mu_name
              ).attached_policies
              attached_policies.each { |a|
                if !configured_policies.include?(a.policy_name)
                  MU.log "Removing IAM policy #{a.policy_name} from role #{@mu_name}", MU::NOTICE
                  MU::Cloud::AWS::Role.purgePolicy(a.policy_arn)
                end
              }
            end

            @config['iam_policies'].each { |policy|
              policy_name = @mu_name+"-"+policy.keys.first.upcase

              arn = "arn:"+(MU::Cloud::AWS.isGovCloud? ? "aws-us-gov" : "aws")+":iam::"+MU.account_number+":policy/#{@deploy.deploy_id}/#{policy_name}"
              resp = begin
                desc = MU::Cloud::AWS.iam.get_policy(policy_arn: arn)

                version = MU::Cloud::AWS.iam.get_policy_version(
                  policy_arn: arn,
                  version_id: desc.policy.default_version_id
                )
                if version.policy_version.document != URI.encode(JSON.generate(policy.values.first), /[^a-z0-9\-]/i)
                  MU.log "Updating IAM policy #{policy_name}", MU::NOTICE, details: policy.values.first
                  begin
                    MU::Cloud::AWS.iam.create_policy_version(
                      policy_arn: arn,
                      set_as_default: true,
                      policy_document: JSON.generate(policy.values.first)
                    )
                  rescue Aws::IAM::Errors::LimitExceeded => e
                    delete_version = MU::Cloud::AWS.iam.list_policy_versions(
                      policy_arn: arn,
                    ).versions.last.version_id
                    MU.log "Purging oldest version (#{delete_version}) of IAM policy #{policy_name}", MU::NOTICE
                    MU::Cloud::AWS.iam.delete_policy_version(
                      policy_arn: arn,
                      version_id: delete_version
                    )
                    retry
                  end
                  MU::Cloud::AWS.iam.get_policy(policy_arn: arn)
                else
                  desc
                end

              rescue Aws::IAM::Errors::NoSuchEntity => e
                MU::Cloud::AWS.iam.create_policy(
                  policy_name: policy_name,
                  path: "/"+@deploy.deploy_id+"/",
                  policy_document: JSON.generate(policy.values.first),
                  description: "Generated from inline policy document for Mu role #{@mu_name}"
                )
              end

              if !@config['bare_policies'] and
                 !attached_policies.map { |p| p.policy_name }.include?(policy_name)
                MU.log "Attaching IAM policy #{policy_name} to role #{@mu_name}"
                MU::Cloud::AWS.iam.attach_role_policy(
                  policy_arn: arn,
                  role_name: @mu_name
                )
              end

            }
          end
        end

        # Return a hash containing a +role+ element and a +policies+ element,
        # populated with one or both depending on what this resource has
        # defined.
        def cloud_desc
          desc = {}
          if @config['bare_policies']
            desc["policies"] = MU::Cloud::AWS.iam.list_policies(
              path_prefix: "/"+MU.deploy_id+"/"
            ).policies
            desc["policies"].reject! { |p|
              !p.policy_name.match(/^#{Regexp.quote(@mu_name)}-/)
            }
          else
            desc["role"] = MU::Cloud::AWS.iam.get_role(
              role_name: @mu_name
            ).role
            if @config['iam_policies']
              desc["policies"] = []
              MU::Cloud::AWS.iam.list_attached_role_policies(
                role_name: @mu_name
              ).attached_policies.each { |p|
                desc["policies"] << MU::Cloud::AWS.iam.get_policy(
                  policy_arn: p.policy_arn
                ).policy
              }
            end

          end

          desc
        end

        # Return the metadata for this user cofiguration
        # @return [Hash]
        def notify
          MU.structToHash(cloud_desc)
        end

        # Delete an IAM policy, along with attendant versions and attachments.
        # @param policy_arn [String]: The ARN of the policy to purge
        def self.purgePolicy(policy_arn)
          attachments = MU::Cloud::AWS.iam.list_entities_for_policy(
            policy_arn: policy_arn
          )
          attachments.policy_users.each { |u|
            MU::Cloud::AWS.iam.detach_user_policy(
              user_name: u.user_name,
              policy_arn: policy_arn
            )
          }
          attachments.policy_groups.each { |g|
            MU::Cloud::AWS.iam.detach_role_policy(
              group_name: g.group_name,
              policy_arn: policy_arn
            )
          }
          attachments.policy_roles.each { |r|
            MU::Cloud::AWS.iam.detach_role_policy(
              role_name: r.role_name,
              policy_arn: policy_arn
            )
          }
          versions = MU::Cloud::AWS.iam.list_policy_versions(
            policy_arn: policy_arn,
          ).versions
          versions.each { |v|
            next if v.is_default_version
            MU::Cloud::AWS.iam.delete_policy_version(
              policy_arn: policy_arn,
              version_id: v.version_id
            )
          }

          MU::Cloud::AWS.iam.delete_policy(
            policy_arn: policy_arn
          )
        end

        # Remove all roles associated with the currently loaded deployment.
        # @param noop [Boolean]: If true, will only print what would be done
        # @param ignoremaster [Boolean]: If true, will remove resources not flagged as originating from this Mu server
        # @param region [String]: The cloud provider region
        # @return [void]
        def self.cleanup(noop: false, ignoremaster: false, region: MU.curRegion, flags: {})

          resp = MU::Cloud::AWS.iam.list_policies(
            path_prefix: "/"+MU.deploy_id+"/"
          )
          if resp and resp.policies
            resp.policies.each { |policy|
              MU.log "Deleting IAM policy /#{MU.deploy_id}/#{policy.policy_name}"
              if !noop
                purgePolicy(policy.arn)
              end
            }
          end

          resp = MU::Cloud::AWS.iam.list_roles(
            path_prefix: "/"+MU.deploy_id+"/"
          )
          if resp and resp.roles
            resp.roles.each { |r|
              MU.log "Deleting IAM role #{r.role_name}"
              if !noop
                MU::Cloud::AWS.iam.delete_role(
                  role_name: r.role_name
                )
              end
            }
          end

        end

        # Locate an existing user group.
        # @param cloud_id [String]: The cloud provider's identifier for this resource.
        # @param region [String]: The cloud provider region.
        # @param flags [Hash]: Optional flags
        # @return [OpenStruct]: The cloud provider's complete descriptions of matching user group.
        def self.find(cloud_id: nil, region: MU.curRegion, flags: {})
          found = nil

          found
        end

        def bindTo(entitytype, entityname)
        end

        def bindPolicyto(policyname, entitytype, entityname)
          if entitytype == "user"
            resp = MU::Cloud::AWS.iam.list_attached_user_policies(
              path_prefix: "/"+@deploy.deploy_id+"/",
              user_name: entityname
            )
            if !resp or !resp.attached_policies.map { |p| p.policy_name }.include?(policy_name)
              MU.log "Attaching policy #{policy_name} to user #{entityname}", MU::NOTICE
              MU::Cloud::AWS.iam.attach_user_policy(
                policy_arn: arn,
                user_name: entityname
              )
            end
          end
        end

        # Cloud-specific configuration properties.
        # @param config [MU::Config]: The calling MU::Config object
        # @return [Array<Array,Hash>]: List of required fields, and json-schema Hash of cloud-specific configuration parameters for this resource
        def self.schema(config)
          toplevel_required = []
          schema = {
            "tags" => MU::Config.tags_primitive,
            "optional_tags" => MU::Config.optional_tags_primitive,
            "bare_policies" => {
              "type" => "boolean",
              "default" => false,
              "description" => "Do not create a role, but simply create the policies specified in +iam_policies+ for direct attachment to other entities."
            },
            "allowed_services" => {
              "type" => "array",
              "items" => {
                "type" => "string",
                "description" => "The name of a service which is allowed to assume this role, such as +ec2.amazonaws.com+. See also https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-service.html#roles-creatingrole-service-api. For an unofficial list of service names, see https://gist.github.com/shortjared/4c1e3fe52bdfa47522cfe5b41e5d6f22"
              }
            },
            "allowed_entities" => {
              "type" => "array",
              "items" => {
                "type" => "string",
                "description" => "An IAM resource or full ARN which should be permitted to assume this role, like +saml-provider/egt-labs-saml-idp+ or +arn:aws:iam::616552976502:saml-provider/egt-labs-saml-idp+."
              }
            },
            "iam_policies" => {
              "type" => "array",
              "items" => {
                "description" => "A key (name) with a value that is an Amazon-compatible policy document. This is not the recommended method for granting permissions- we suggest listing +roles+ for the user instead. See https://docs.aws.amazon.com/IAM/latest/RoleGuide/access_policies_examples.html for example policies.",
                "type" => "object"
              }
            }
          }
          [toplevel_required, schema]
        end

        # Cloud-specific pre-processing of {MU::Config::BasketofKittens::roles}, bare and unvalidated.
        # @param role [Hash]: The resource to process and validate
        # @param configurator [MU::Config]: The overall deployment configurator of which this resource is a member
        # @return [Boolean]: True if validation succeeded, False otherwise
        def self.validateConfig(role, configurator)
          ok = true

          if role["bare_policies"] and (!role["iam_policies"] or role["iam_policies"].empty?)
            MU.log "IAM role #{role['name']} has bare_policies set, but no iam_policies specified", MU::ERR
            ok = false
          end

          if (!role['allowed_services'] or role['allowed_services'].empty?) and
             (!role['allowed_entities'] or role['allowed_entities'].empty?) and
             !role["bare_policies"]
            MU.log "IAM role #{role['name']} must specify at least one of allowed_services or allowed_entities", MU::ERR
            ok = false
          end

          ok
        end

        private

        def get_tag_params(strip_std = false)
          @config['tags'] ||= []

          if !strip_std
            MU::MommaCat.listStandardTags.each_pair { |key, value|
              @config['tags'] << { "key" => key, "value" => value }
            }

            if @config['optional_tags']
              MU::MommaCat.listOptionalTags.each { |key, value|
                @config['tags'] << { "key" => key, "value" => value }
              }
            end
          end

          @config['tags'].map { |t|
            { :key => t["key"], :value => t["value"] }
          }
        end

        def gen_role_policy_doc
          role_policy_doc = {
            "Version" => "2012-10-17",
          }

          statements = []
          if @config['allowed_services']
            @config['allowed_services'].each { |svc|
              statements << {
                "Effect" => "Allow",
                "Action" => "sts:AssumeRole",
                "Principal" => {
                  "Service" => svc
                }
              }
            }
          end

          role_policy_doc["Statement"] = statements

          JSON.generate(role_policy_doc)
        end

      end
    end
  end
end
