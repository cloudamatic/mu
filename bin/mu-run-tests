#!/usr/local/ruby-current/bin/ruby
# Copyright:: Copyright (c) 2019 eGlobalTech, Inc., all rights reserved
#
# Licensed under the BSD-3 license (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the root of the project or at
#
#     http://egt-labs.com/mu/LICENSE.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

bindir = File.realpath(File.expand_path(File.dirname(__FILE__)))
dir = File.realpath(File.expand_path(bindir+"/../modules/tests"))
Dir.chdir(dir)

require 'colorize'
require 'optimist'
require bindir+"/mu-load-config.rb"
require 'mu'

require 'rubygems'
require 'bundler/setup'
require 'json'
require 'erb'
require 'json-schema'

$opts = Optimist::options do
  banner <<-EOS
Usage:
#{$0} [-e <environment>] [-r region] [-v] [-d] [-w] [-c] [-n] [-s] [-j] [-p parameter=value] /path/to/stack/config.[json|yaml] [-u deploy_id [-l]] [-r deploy_id]
  EOS
  opt :max_threads, "Environment to set on creation.", :require => false, :default => 3, :type => :integer
  opt :full, "Actually run deploys, instead of --dryrun", :require => false, :default => false
end

files = Dir.glob("*.yaml", base: dir)
files.concat(Dir.glob("*.yml", base: dir))
baseclouds = MU::Cloud.supportedClouds.reject { |c| c == "CloudFormation" }

commands = {}
failures = []

files.each { |f|
  clouds = baseclouds.dup
  File.open(dir+"/"+f).readlines.each { |l|
    l.chomp!
    next if !l.match(/^\s*#\s*clouds: (.*)/)
    clouds = []
    cloudstr = Regexp.last_match[1]
    cloudstr.split(/\s*,\s*/).each { |c|
      baseclouds.each { |cloud|
        if cloud.match(/^#{Regexp.quote(c)}$/i)
          clouds << cloud
        end
      }
    }
    break
  }
  clouds.each { |cloud|
    cmd = "mu-deploy #{f} --cloud #{cloud} #{$opts[:full] ? "" : "--dryrun"}"
    commands[cmd] = {
      "file" => f,
      "cloud" => cloud,
    }
    if $opts[:full]
      $environment = "dev"
      begin
        conf_engine = MU::Config.new(f, cloud: cloud)
      rescue StandardError => e
        MU.log e.message+" parsing "+f+" with cloud "+cloud, MU::WARN, details: e.backtrace
        failures << f+" ("+commands[cmd]["cloud"]+")"
        next 
      end
      parsed = MU::Config.stripConfig(conf_engine.config)
      types = []
      MU::Cloud.resource_types.values.each { |attrs|
        if parsed.has_key?(attrs[:cfg_plural])
          types << attrs[:cfg_plural]
        end
      }
      commands[cmd]["parsed"] = parsed
      commands[cmd]["types"] = types
    end
  }
}

puts "Running #{commands.size.to_s.bold} #{$opts[:full] ? "full deploy" : "parse"} tests from #{files.size.to_s.bold} Baskets of Kittens across #{baseclouds.size.to_s.bold} clouds"

threads = []
results = {}
commands.keys.each { |cmd|
  if threads.size >= $opts[:max_threads]
    begin
      threads.each { |t| t.join(0.1) }
      threads.reject! { |t| t.nil? or !t.status }
      sleep 1 if threads.size >= $opts[:max_threads]
    end while threads.size >= $opts[:max_threads]
  end

  threads << Thread.new(cmd) { |cmd_thr|
    results[cmd_thr] = {}
    puts %Q{#{cmd_thr} 2>&1}
    results[cmd_thr]["output"] = %x{#{cmd_thr} 2>&1}
    if $?.exitstatus != 0
      results[cmd_thr]["status"] = false
      print ".".light_red
    else
      results[cmd_thr]["status"] = true
      print ".".green
    end
    if $opts[:full] and results[cmd_thr]["output"].match(/deploy - Deployment id: .*? \((.*?)\)/)
      deploy_id = Regexp.last_match[1]
      adoptdir = Dir.mktmpdir(commands[cmd_thr]["file"].gsub(/[^a-z0-9]|yaml$/i, ""))
      if commands[cmd_thr]["types"] and commands[cmd_thr]["types"].size > 0
        adopt = "cd #{adoptdir} && mu-adopt --appname adoptone --grouping omnibus  --clouds #{commands[cmd_thr]["cloud"]} --types #{commands[cmd_thr]["types"].join(" ")} 2>&1"
        puts adopt
        results[cmd_thr]["output"] += %x{#{adopt}}
        results[cmd_thr]["status"] = false if $?.exitstatus != 0
      end

      if File.exist?(dir+"/regrooms/"+commands[cmd_thr]["file"])
        regroom = "mu-deploy regrooms/#{commands[cmd_thr]["file"]} --cloud #{commands[cmd_thr]["cloud"]} --update #{deploy_id} 2>&1"
        puts regroom
        results[cmd_thr]["output"] += %x{#{regroom}}
        results[cmd_thr]["status"] = false if $?.exitstatus != 0
        if commands[cmd_thr]["types"] and commands[cmd_thr]["types"].size > 0
          re_adopt = "cd #{adoptdir} && mu-adopt --appname adopttwo --grouping omnibus --clouds #{commands[cmd_thr]["cloud"]} --types #{commands[cmd_thr]["types"].join(" ")} 2>&1"
          puts re_adopt
          results[cmd_thr]["output"] += %x{#{re_adopt}}
          results[cmd_thr]["status"] = false if $?.exitstatus != 0
        end
# TODO big flex is to read back both adopted BoKs and .diff them, but without
# all resources having implemented adoption this isn't much of a test yet
      end

      FileUtils.remove_entry(adoptdir)

      results[cmd_thr]["output"] += %x{mu-cleanup #{deploy_id} --skipsnapshots}
      results[cmd_thr]["status"] = false if $?.exitstatus != 0
    end
  }
}
threads.each { |t|
  t.join
}
puts ""

results.keys.sort { |a, b|
      if results[b]["status"] and !results[a]["status"]
        1
      elsif !results[b]["status"] and results[a]["status"]
        -1
      else
        0
      end
    }.each { |cmd|
  if !results[cmd]["status"]
    puts cmd+" failed:".light_red
    puts results[cmd]["output"].yellow
    puts "^ #{cmd}".light_red
    failures << commands[cmd]["file"]+" ("+commands[cmd]["cloud"]+")"
  else
    puts cmd+" passed".green
  end
}

if failures.size > 0
  puts "\n#{failures.size.to_s.bold} failure#{failures.size == 1 ? "" : "s"} in "+failures.uniq.map { |f| f.light_red }.join(", ")
  exit 1
end
